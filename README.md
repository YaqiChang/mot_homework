# 项目结构
```
  project_root/
  │
  ├── config.py          # 全局配置：时间步长、总时长、单位换算，三部雷达坐标，
  │                     # 交汇点 F、干扰/遮蔽区域、杂波区域、噪声参数、LMB 超参等
  │
  ├── data_gen.py        # 场景与观测数据生成：
  │                     # - 生成两目标 A/B 的真值轨迹（含机动与交汇）
  │                     # - 根据雷达布置和遮蔽/干扰模型生成点目标 / 扩展目标量测
  │                     # - 在指定区域内生成泊松杂波
  │                     # - 提供 in_jam_region 等场景判断函数
  │
  ├── models.py          # 跟踪相关的数据结构：
  │                     # - 扩展目标状态
  │                     # - Bernoulli 组件
  │                     # - LMB 状态等
  │
  ├── tracker_lmb.py     # LMB 跟踪器实现：
  │                     # - 状态预测与更新
  │                     # - 量测关联、gating 与组件管理
  │                     # - 输出多目标的当前位置估计
  │
  ├── metrics.py         # 评估指标与统计：
  │                     # - 位置 RMSE、OSPA 距离
  │                     # - 基数误差及 bias
  │                     # - 检测召回率
  │                     # - 混淆矩阵及辅助统计
  │                     # - ID 分配与假目标统计等
  │
  ├── utils.py           # 辅助工具函数：
  │                     # - 几何与距离计算
  │                     # - gating、聚类等通用小工具
  │
  ├── plot.py            # 静态结果绘图：
  │                     # - 轨迹对比图（真值 vs 估计）
  │                     # - OSPA / RMSE / Cardinality 随时间曲线
  │                     # - ID–真值时间轴、召回率曲线
  │                     # - 混淆矩阵热力图
  │                     # - 指定时刻的量测快照、雷达检测/距离随时间图等
  │
  ├── main.py            # 主实验入口：
  │                     # - 调用 data_gen 生成真值轨迹与量测
  │                     # - 使用 LMBTracker 进行全程多目标跟踪
  │                     # - 计算并打印/保存各类评价指标
  │                     # - 调用 plot.py 输出静态结果图到 results/
  │
  ├── dynamic_sim.py     # 动态场景 + 跟踪效果仿真与可视化（动画）：
  │                     # - 与 main.py 一致的场景和滤波流程
  │                     # - 帧间动态展示：真值轨迹、当前量测、跟踪估计及不确定性椭圆
  │                     # - 右侧子图实时展示 OSPA、RMSE、基数等指标随时间变化
  │                     # - 可选保存 GIF，用于展示“跟踪算法表现”
  │
  ├── scene_sim.py       # 场景还原专用动态仿真（动画）：
  │                     # - 只展示真值轨迹与场景元素（无跟踪结果）
  │                     # - 可视化全球直角坐标系（km）、三部雷达、交汇点 F、
  │                     #   干扰区、杂波区域，以及 A_start/B_start 位置
  │                     # - 适合用于说明/证明“题目要求的场景设置”
  │
  ├── fonts/             # 字体资源目录：
  │   └── SimHei.ttf     # 中文黑体，用于图中的中文标注（坐标轴名、区域说明等）
  │
  ├── results/           # 结果输出目录：
  │   ├── *.png          # main.py 调用 plot.py 生成的各类静态图
  │   └── metrics_summary.txt  # 指标摘要文本
  │
  ├── README.md          # 项目总览与使用说明（可根据需要补充/更新）
  │
  ├── 题目分析.md        # 原题目与场景设定的分析
  ├── 代码逻辑.md        # 代码结构与主要流程说明
  ├── 结果分析.md        # 实验结果与指标的分析、结论
  ├── 修改说明.md        # 关键修改记录与版本变更说明
  └── GLMB.md            # GLMB/LMB 理论背景和推导笔记

```

# TODOLIST 
- [x] 需要补充结果分析，包括：1）绘图函数，可以不是动态的
- [ ] 2）常见的指标需要分析出来。为什么有这样的结果xxxxx  
- [x] 需要按着题目分析里面那个逻辑（除了上面的术语说明），建议是：先把题目列出来，然后从题目转换成简短的几条有效信息（做数学题时候的列已知条件），然后数学建模，分析xxxxxxx
- [x] 可以考虑加其他算法，但是参数设定有很麻烦，要不就算了。首先接感觉能不能把现有的参数优化以下得到一个更好的结果。---已经更新成GLMB
- [ ] 可以AI解读代码关键部分，制作PPT
修改代码相关的内容加在对应的py文件里面。没用什么包，就matplotlib和numpy

# 修改说明和分析说明
见[修改说明](修改说明.md)，[结果分析说明](结果分析.md)

# 混淆矩阵分析
传统混淆矩阵用于分类任务，而在多目标跟踪任务中，“混淆” 是指：

真实状态	发生情况	归到什么 cell
真实目标 A	被正确跟踪为 A	TP_AA
真实目标 A	被误跟踪为 B	Confusion AB
真实目标 A	被漏掉（无 track）	FN_A
无真实目标（假目标）	被跟踪器输出为某 label	FP(track)

所以混淆矩阵是一个 (N 真目标 + 1 clutter 行) × (N 估计 + 1 None 列) 的矩阵：

例：A、B 两个真目标：

	A(est)	B(est)	None(漏检)
A(true)	TP_A	Conf_A→B	FN_A
B(true)	Conf_B→A	TP_B	FN_B
Clutter	FP_→A	FP_→B	—

## 实现的混淆矩阵分析包括
在 main.py 运行时直接给出对应数字，同时写进 metrics_summary.txt：

  1. A 被多少帧误认为 B？
      - 使用混淆矩阵 C[0, 1]：
      - 控制台输出：A 被误认为 B 的帧数: ...
  2. B 被误认为 A 的次数？
      - 使用 C[1, 0]：
      - 输出：B 被误认为 A 的帧数: ...
  3. 假目标出现多少？（假 track 总数）
      - 使用 build_id_assignment_series 做逐帧最近邻匹配，对每帧每个 track 判定
        是否匹配到 A/B；
      - 所有被标为 "None" 的 track 计为“假目标一次”（按 time×track 计数）；
      - 输出：假目标（未匹配任何真值）的总次数: ...
  4. A/B 各漏检了多少帧？
      - 来自混淆矩阵的 None 列：
          - A 漏检：C[0, 2]
          - B 漏检：C[1, 2]
      - 输出：
          - A 漏检帧数: ...
          - B 漏检帧数: ...
  5. GLMB 在干扰区是否频繁产生假警？
      - 对所有假目标（上面 "None" 的那些 track），检查它们的位置是否落在干扰区
        （用 in_jam_region(pos, t) 判断）；
      - 统计总次数 false_in_jam：
      - 输出：其中位于干扰区内的假警次数: ...
      - 你可以直接用 false_in_jam / false_total 看假警中有多少发生在干扰区，也可
        以对比时间长度自己判断是否“频繁”。

  另外：

  - 这些统计会被追加写入 metrics_summary.txt，方便你事后看数值：
      - A_as_B, B_as_A
      - A_missed, B_missed
      - False targets total
      - False targets inside jamming area
  - confusion_matrix.png 仍然是 2×3 热力图（True A/B × Pred A/B/None），用来配合
    这些数字做直观分析。


