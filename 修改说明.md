feat: 对齐 GLMB 指标统计并完善可视化分析

  概要

  - 对齐 dynamic_sim.py 与 main.py 的滤波与指标逻辑，保证动画和离线评估一致。
  - 扩展指标计算与可视化，新增 ID 时间轴、召回率曲线和混淆矩阵等分析结果。
  - 优化仿真动图的显示效果（雷达、干扰区、轨迹样式等），提升可读性。

  详细改动

  - 主流程 main.py
      - 使用最新 metrics 函数，按统一方式计算：
          - 位置 RMSE（A/B）、基数误差、OSPA 平均距离。
      - 新增输出文件：
          - metrics_summary.txt：汇总打印所有关键指标。
          - traj_result.png：真值/估计轨迹对比。
          - metrics_over_time.png：OSPA / RMSE / Cardinality 随时间曲线。
          - id_timeline.png：label–真值 ID 时间轴。
          - detection_recall.png：A/B 在线召回率曲线。
          - confusion_matrix.png：2×3 ID 混淆矩阵热力图。
      - 基于混淆矩阵和最近邻分配，新增统计并打印：
          - A 被误认为 B 帧数、B 被误认为 A 帧数。
          - A/B 各自的漏检帧数。
          - 假目标（未匹配真值）的总次数，以及其中位于干扰区内的假警次数。
  - 指标工具 metrics.py
      - 丰富指标接口：
          - 逐帧 RMSE、逐帧 Cardinality、逐帧 Detection Recall。
          - build_id_assignment_series：逐帧 label→真值 ID 的最近邻匹配结果。
          - _ospa_single_timestep 与 compute_ospa_over_time 支持返回时序。
          - compute_confusion_matrix：输出 2×3(ID vs 真值) 混淆矩阵。
  - 绘图工具 plot.py
      - 继续使用 plot_trajectories、plot_measurements_snapshot。
      - 新增：
          - plot_metrics_over_time：OSPA / RMSE / Cardinality 三联图。
          - plot_id_timeline：label→真值 的时间轴散点图。
          - plot_detection_recall：A/B 的累积召回率随时间曲线。
          - plot_confusion_matrix：绘制混淆矩阵热力图。
  - 动态仿真 dynamic_sim.py
      - 先按与 main.py 完全一致的方式跑一遍 LMB，缓存 est_series、椭圆信息和
        label2truth，用这些结果驱动动画。
      - 使用 label2truth 标注椭圆为 A(ID0) / B(ID1) 格式，ID 对齐离线评估。
      - 场景可视化优化：
          - 放大画布与字体，增强对比度。
          - 雷达符号和覆盖圈加粗、放大，文字加粗。
          - Jamming Area 改为明亮黄色实心圆，黑色加粗标注，并加入图例。
          - A/B 真值轨迹和估计轨迹使用清晰区分的颜色和线型，当前帧真值点用大号
            marker 高亮。
      - 右侧指标面板的 OSPA/RMSE/Cardinality 曲线与 main.py 的统计方式保持一致，
        Info 面板显示累积召回率和基数误差。
  - 配置与参数
      - 将总仿真时间 TOTAL_TIME 从 200s 延长至 300s，便于观察 jamming 段之后
        Cardinality 的恢复。
      - 适度调整 LMB/GLMB 的存在概率阈值、生存概率等参数，以提高 B 的召回率并维
        持合理的基数误差（保持在当前表现良好的版本上）。


# 最新改动 +了一个 radar_detection_overtime图，修改压制干扰作用的雷达，只对R2

  - 当 R1–目标距离 > 50 km 时，对应 R1 曲线的有效量测数应 ≈ 1；
  - 当 R1–目标距离 < 50 km 时（距离曲线下穿 50 km 虚线），R1 的有效量测数
    会跳到 8~15 左右；
  - 这个切换点就直观对齐了“点目标 / 扩展目标”的分界。
  但是作用区域重叠 还是看不出来
  -----
  最终解决方案：
  ```
  关键点有两个：

  1. 压制只在数据生成阶段、只对 R2 生效
     在 data_gen.py:212-260，生成真目标量测时的判断是：

     # A
     if not (radar_id == "R2" and in_jam_region(posA, t)):
         ...  # 生成 A 的量测

     # B
     if not (radar_id == "R2" and in_jam_region(posB, t)):
         ...  # 生成 B 的量测

     这里硬编码了 radar_id == "R2"，R1/R3 根本没进这个条件，因此不会因为
     in_jam_region 被屏蔽。

  2. 现在看到 R2/R3 曲线“几乎一样”，是因为 JAM_START_T/JAM_END_T 根本没
     打在目标经过干扰区的时间上
      - 当前配置里 JAM_START_T = 40.0, JAM_END_T = 80.0（config.py:44-
        52）。
      - A 从大约 x≈103 km 沿 x 轴向左，以 500 m/s 运动；干扰区域中心在
        x≈34 km。
      - 算一算 A 穿过干扰区的大致时间是 130~140 s 这一段，而不是 40~80 s。
      - 换句话说，在 40~80 s 这段时间里，in_jam_region(pos, t) 基本一直是
        False，压制逻辑根本没有触发，R2 和 R3 都是“正常工作”，自然曲线就
        很像。

     你在新图上看到 R2/R3 在阴影区数值都偏低，很可能原因是：那段时间 B 还
     没出生、或者目标离雷达都比较远，只产生点量测（每帧 1 个），跟压制无
     关，只是我们把阴影画在了一个“错误的时间段”上，看起来像“都被压制”。

  ———

  怎么改成你预期的效果

  - 保持现在“只对 R2 压制”的代码逻辑不动；
  - 把时间窗改到目标真正经过干扰区域的时段，例如：

    # config.py
    JAM_START_T = 130.0
    JAM_END_T   = 150.0   # 备注：我原来用的60 80 
  - 然后重新跑 python main.py，看 results/radar_detection_over_time.png：
      - R1、R3 子图应该是平滑的（只受点/扩展目标切换影响）；
      - R2 子图在 [JAM_START_T, JAM_END_T] 范围内有效量测数应该明显掉到 0
        左右，这时才是真正的“只对 R2 压制”。

```



# 最新改动 +了一个 画图函数证明
  ==对比detection_over-time和distance-overtime能够证明点量测和扩展量测！！！==

