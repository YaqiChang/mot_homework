# ✅ **GLMB/LMB 目标跟踪系统*

以下总结了我们从初版到完整可视化、可评估版本的所有关键修改步骤。

---

# 🔧 **一、数据生成与仿真模块（data\_gen / dynamic\_sim）**

### 1\. **目标出现时刻建模错误 → 修复 B 出生逻辑**

**问题**：

-   B 的真值虽然存在，但在动画/跟踪中“看不到 B”，轨迹为空。
    

**原因**：

-   `dynamic_sim` 把 B 视为“每帧动态判断”，而真实的 B 出生逻辑应该是**确定一个 first\_B\_idx**，只在那一帧加入滤波器。
    

**修改**：

-   添加 `first_B_idx` 计算（从真值中查找非 NaN 时刻）。
    
-   在 B 出生帧：**加入 B 但不 step()**（与 GLMB 结构一致）。
    
-   下一帧起正常 step()。
    

**结果**：  
✔ B 在动画和数值指标中真正出现、被跟踪。  
✔ 生命周期与真值一致。

---

### 2\. **画图轨迹线缩进错误 → 修复**

由于缩进错位，一段轨迹线初始化代码被错误嵌套，导致图像内元素不刷新。

**修改**：  
☑ 修正缩进，统一成：

```python
est_lines = {
   'A': ax.plot(...),
   'B': ax.plot(...),
}
```

---

# 🔧 **二、跟踪器调用逻辑（main.py / dynamic\_sim.py）**

### 1\. **GLMB 初始化必须与真实场景一致**

你要求 **main 与动态图 dynamic\_sim 完全一致**。

**修复动作**：

-   A 在第 0 帧加入
    
-   B 在 first\_B\_idx 帧加入
    
-   出生帧不 step()，仅添加目标并取当前状态
    
-   其它帧均正常 `tracker.step(meas_k, t)`
    

**结果**：  
✔ 仿真与数值计算一致，不再出现“动画看到两个目标，但 main 结果显示只有一个”的不一致。

---

# 🔧 **三、基础指标体系（metrics.py）修复与强化**

### 1\. **新增：逐帧 OSPA(t)**

原来只有平均 OSPA，现在加入曲线：

✔ 能观察 Jam 区进入/退出时性能变化  
✔ 能看漏检/假检导致的突刺

---

### 2\. **新增：逐帧 RMSE(t)**

用于观察：

-   B 出生前后误差
    
-   遮蔽区误差
    
-   假警干扰波动
    

---

### 3\. **新增：逐帧 Cardinality 曲线**

包括：

-   true\_counts(t)
    
-   est\_counts(t)
    
-   errors(t)
    

✔ 能清楚看到 GLMB 是否产生假 track  
✔ Jam 区是否升高假目标数量

---

### 4\. **新增：检测召回率（Recall over time）**

给每个目标（A/B）：

-   逐帧是否成功估计
    
-   累积召回率曲线
    

✔ 用来验证滤波器稳定性  
✔ 判断劳动阶段是否漏检

---

### 5\. **新增：ID Assignment 序列 build\_id\_assignment\_series()**

这是后面混淆矩阵、ID 时间轴图的基础。

✔ 每帧每个 track 分配到真实 A/B/None  
✔ 编解码器行为可查看

---

# 🔧 **四、高级指标体系（Confusion Matrix）**

### 1\. **引入多目标跟踪领域专用的混淆矩阵**

不同于分类任务，这里的混淆矩阵定义为：

| True \\ Est | A | B | None |
| --- | --- | --- | --- |
| A | TP | A→B 混淆 | FN |
| B | B→A 混淆 | TP | FN |
| Clutter | FP→A | FP→B | — |

**修改**：

-   添加 compute\_confusion\_matrix()
    
-   添加 plot\_confusion\_matrix()
    
-   main.py 自动生成 confusion\_matrix.png
    

**效果**：  
✔ 完成一个“识别视角”的质量评估  
✔ 可量化 GLMB 的 **ID-stability / cross-assignment** 性能

这是科研论文级别的必要内容。

---

# 🔧 **五、绘图体系（plot.py）全面升级**

新增了以下可视化模块：

### 1\. 轨迹总览图 `traj_overview.png`

-   真值轨迹：A、B
    
-   估计轨迹：A\_est、B\_est
    
-   判断整体跟踪精度
    

### 2\. 性能三联图 `metrics_timeseries.png`

-   OSPA vs time
    
-   RMSE vs time
    
-   Cardinality vs time
    

### 3\. ID 时间轴图 `id_timeline.png`

-   每个 label 在不同时刻属于哪个真值
    
-   清晰展示 GLMB 是否 ID-switching
    

### 4\. 检测召回率曲线 `recall_timeseries.png`

-   A、B 的检测召回率趋势
    

### 5\. 量测点云快照图 `meas_step060.png`

-   不同雷达
    
-   杂波 vs 真实量测
    
-   真值 / 估计位置
    

全部自动保存，不弹窗。

---

# 🔧 **六、main.py 最终整合**

我们对 main.py 进行了结构化升级：

1.  跟踪逻辑与 dynamic\_sim 完全一致
    
2.  自动记录所有中间结果
    
3.  自动计算所有指标
    
4.  自动绘制所有图
    
5.  自动打印所有 summary 指标
    

最终 main.py 成为 **完整的 GLMB 评估与可视化 pipeline**。

---

# 🎯 **七、最终系统能力（重要总结）**

你的系统现在是：

✔ **真实 + 多雷达 + 杂波 + Jam 区干扰仿真**  
✔ **GLMB/LMB 多目标跟踪核心算法（完整）**  
✔ **多指标评估体系**

-   RMSE（总体+逐帧）
    
-   Cardinality error（总体+逐帧）
    
-   OSPA（总体+逐帧）
    
-   Recall 曲线
    
-   Confusion Matrix  
    ✔ **可视化体系（全部保存）**
    
-   轨迹总览图
    
-   性能三联图
    
-   ID 时间轴图
    
-   混淆矩阵图
    
-   量测点云快照  
    ✔ **动画（dynamic\_sim）**  
    ✔ **统一一致的出生逻辑（A/B）**


# 为什么用GLMB
在本次作业/项目中，我最终采用了带标签的多 Bernoulli 滤波框架（简化 GLMB 形式），不是一开始就如此设计，而是在逐步实验中暴露出一系列问题后，才发现需要从单假设 LMB 提升到多假设 GLMB。具体原因可以从以下几个方面客观说明：

B 目标长期“检测不到”，轨迹难以维持
在早期的单假设 LMB 实现中，数据关联采取贪心策略：一簇扩展量测只会分配给一条轨迹。
当 A、B 靠得较近甚至交汇时，B 的量测经常被 A “抢走”，导致 B 多次出现“没有量测支持”的情况，存在概率 
𝑟
r 被持续压低，最终在滤波器内部等同于“B 不存在”，表现为几乎无 B 轨迹输出。
为解决这一问题，我引入了简化 GLMB 思路：对存在歧义的量测关联保留多个全局假设分支，每个分支对应不同的量测→轨迹分配方案。这样 A、B 都能在某些假设中获得稳定的量测支持，B 的轨迹不再轻易“被吃掉”。

扩展量测处理不当，无法体现目标几何形状
题目要求：近距离时必须作为扩展目标处理，不能简单把一簇点云“凝聚”为一个点后当点目标跟踪。
在早期实现中，我曾将扩展量测简化为单点更新，导致两类问题：

一方面违背了题目对扩展目标建模的约束；

另一方面，扩展形状矩阵 
𝑆
S 几乎不被有效更新，形状估计与真实点云分布偏差较大。
在当前版本中，我将点目标与扩展目标的更新过程区分开来：

点量测调用 update_with_point；

扩展量测使用点集的均值与协方差，调用 update_with_extended，同时更新位置、扩展形状和量测率。
这样既满足了扩展目标理论的要求，也显著改善了近距段的位置与形状估计。

交汇区域 ID-switch 严重，无法进行轨迹级分析
本题强调在交汇和遮蔽场景下的轨迹连续性与 ID 保持。然而，在只有单一关联假设的 LMB 框架下，一旦在 F 点附近的几帧中量测分配略有偏差，就会出现 A/B 标签互换的问题。
ID-switch 发生后，无论后续 RMSE 还是 OSPA 度量都难以准确反映“哪条轨迹对应哪一个物理目标”，很难支撑后续的算法对比与分析。
引入 GLMB 之后，我显式维护若干全局假设，对关键帧的多种关联结果进行并行评估，通过权重归一化和剪枝保留最合理的几条。这样一来，“保持 A/B 标签不交换”的那类假设会在权重上占优势，使最终输出的轨迹在交汇段可以维持较好的 ID 一致性。

遮蔽 / 压制干扰期间轨迹容易被误判“死亡”
在题设的遮蔽/压制干扰区内，2 号雷达在一段时间内对目标几乎“看不见”。在早期版本中，我没有对这种“系统性漏检”做区分，仍按普通漏检逻辑强烈压低存在概率 。
结果是：轨迹一旦进入干扰区域，多个连续时刻没有量测命中， 𝑟快速衰减到阈值以下，导致轨迹被删除，穿越干扰区后的目标无法自然“接上”。
在当前实现中，我显式检测位置是否处于干扰区域内：

若是处于 jam 区，我只保留生存概率带来的自然衰减，不额外因“无量测”再压低 𝑟；

若是普通漏检，才按常规策略处理。
这一改动使得轨迹可以跨越遮蔽/干扰时段持续存在，更符合物理场景。

强杂波环境下容易产生虚假轨迹与发散
场景中杂波强度较高，单帧杂波点数较多。在单假设 LMB 模式下，一旦某些杂波点被错误关联到现有轨迹，或者触发新的出生轨迹，就可能导致：

虚假轨迹长期存在；

真实轨迹位置被杂波“拽”向错误位置，误差发散。
使用 GLMB 之后，我通过多假设分支显式考虑“量测为杂波”的可能性，不同分支对应“接收该量测”或“拒绝该量测”。在后续的权重更新过程中，与真实轨迹不一致的分支权重会快速下降；与真实目标运动模式、量测分布更一致的分支得以保留。这样整体上提高了对杂波的鲁棒性，减少了虚假轨迹和发散现象。

综合来看：

本题同时包含扩展目标量测、交汇机动、多雷达、强杂波、遮蔽/干扰以及迟出生目标等多种复杂因素；

若仅采用单假设 LMB 或更简单的 PHD/CPHD，很难同时兼顾“轨迹级 ID 保持”“扩展形状估计”“遮蔽期间轨迹连续性”等要求；

因此，我最终采用了简化 GLMB 框架：在 RFS 的多 Bernoulli 建模基础上，引入少量全局假设，显式保留关键帧的多种关联方案，再通过权重归一化与剪枝选择最合理的假设作为输出。